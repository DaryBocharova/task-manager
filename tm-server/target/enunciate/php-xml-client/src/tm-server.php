<?php

/**
 *
 * 
 *
 * Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
 *
 */
 

namespace Ru\Bocharova\Tm\Entity;

/**
 * (no documentation provided)
 */
class AbstractEntity
{

    /**
     * Constructs a AbstractEntity from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }


    /**
     * Initializes this AbstractEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AbstractEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of AbstractEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AbstractEntity to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
    }
}

namespace Ru\Bocharova\Tm\Entity;

/**
 * (no documentation provided)
 */
class User extends \Ru\Bocharova\Tm\Entity\AbstractEntity
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $login;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $password;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $role;

    /**
     * Constructs a User from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLogin()
    {
        return $this->login;
    }

    /**
     * (no documentation provided)
     *
     * @param string $login
     */
    public function setLogin($login)
    {
        $this->login = $login;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPassword()
    {
        return $this->password;
    }

    /**
     * (no documentation provided)
     *
     * @param string $password
     */
    public function setPassword($password)
    {
        $this->password = $password;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getRole()
    {
        return $this->role;
    }

    /**
     * (no documentation provided)
     *
     * @param string $role
     */
    public function setRole($role)
    {
        $this->role = $role;
    }

    /**
     * Sets a known child element of User from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'login') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->login = $child;
            $happened = true;
        }
        else if (($xml->localName == 'password') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->password = $child;
            $happened = true;
        }
        else if (($xml->localName == 'role') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->role = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of User from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this User to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'user', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this User to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->login) {
            $writer->startElementNs(null, 'login', null);
            $writer->text($this->login);
            $writer->endElement();
        }
        if ($this->password) {
            $writer->startElementNs(null, 'password', null);
            $writer->text($this->password);
            $writer->endElement();
        }
        if ($this->role) {
            $writer->startElementNs(null, 'role', null);
            $writer->text($this->role);
            $writer->endElement();
        }
    }
}

namespace Ru\Bocharova\Tm\Enumerate;

/**
 * (no documentation provided)
 */
class Status
{

    /**
     * (no documentation provided)
     */
    const PLANNED = "PLANNED";

    /**
     * (no documentation provided)
     */
    const INPROCESS = "INPROCESS";

    /**
     * (no documentation provided)
     */
    const DONE = "DONE";
}

namespace Ru\Bocharova\Tm\Enumerate;

/**
 * (no documentation provided)
 */
class Role
{

    /**
     * (no documentation provided)
     */
    const USER = "USER";

    /**
     * (no documentation provided)
     */
    const ADMINISTRATOR = "ADMINISTRATOR";
}

namespace Ru\Bocharova\Tm\Entity;

/**
 * (no documentation provided)
 */
class Task extends \Ru\Bocharova\Tm\Entity\AbstractEntity
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $projectID;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $dateStart;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $dateEnd;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $userID;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $status;

    /**
     * Constructs a Task from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getProjectID()
    {
        return $this->projectID;
    }

    /**
     * (no documentation provided)
     *
     * @param string $projectID
     */
    public function setProjectID($projectID)
    {
        $this->projectID = $projectID;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDateStart()
    {
        return $this->dateStart;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $dateStart
     */
    public function setDateStart($dateStart)
    {
        $this->dateStart = $dateStart;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDateEnd()
    {
        return $this->dateEnd;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $dateEnd
     */
    public function setDateEnd($dateEnd)
    {
        $this->dateEnd = $dateEnd;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getUserID()
    {
        return $this->userID;
    }

    /**
     * (no documentation provided)
     *
     * @param string $userID
     */
    public function setUserID($userID)
    {
        $this->userID = $userID;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * (no documentation provided)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }

    /**
     * Sets a known child element of Task from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'projectID') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->projectID = $child;
            $happened = true;
        }
        else if (($xml->localName == 'dateStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dateStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'dateEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dateEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'userID') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->userID = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Task from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this Task to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'task', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this Task to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->projectID) {
            $writer->startElementNs(null, 'projectID', null);
            $writer->text($this->projectID);
            $writer->endElement();
        }
        if ($this->dateStart) {
            $writer->startElementNs(null, 'dateStart', null);
            $writer->text($this->dateStart);
            $writer->endElement();
        }
        if ($this->dateEnd) {
            $writer->startElementNs(null, 'dateEnd', null);
            $writer->text($this->dateEnd);
            $writer->endElement();
        }
        if ($this->userID) {
            $writer->startElementNs(null, 'userID', null);
            $writer->text($this->userID);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
    }
}

namespace Ru\Bocharova\Tm\Entity;

/**
 * (no documentation provided)
 */
class Session extends \Ru\Bocharova\Tm\Entity\AbstractEntity
{

    /**
     * Constructs a Session from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }


    /**
     * Sets a known child element of Session from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of Session from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this Session to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
    }
}

namespace Ru\Bocharova\Tm\Entity;

/**
 * (no documentation provided)
 */
class Project extends \Ru\Bocharova\Tm\Entity\AbstractEntity
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $dateStart;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $dateEnd;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $userID;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $status;

    /**
     * Constructs a Project from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDateStart()
    {
        return $this->dateStart;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $dateStart
     */
    public function setDateStart($dateStart)
    {
        $this->dateStart = $dateStart;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDateEnd()
    {
        return $this->dateEnd;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $dateEnd
     */
    public function setDateEnd($dateEnd)
    {
        $this->dateEnd = $dateEnd;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getUserID()
    {
        return $this->userID;
    }

    /**
     * (no documentation provided)
     *
     * @param string $userID
     */
    public function setUserID($userID)
    {
        $this->userID = $userID;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * (no documentation provided)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }

    /**
     * Sets a known child element of Project from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'dateStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dateStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'dateEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dateEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'userID') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->userID = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Project from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this Project to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'project', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this Project to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->dateStart) {
            $writer->startElementNs(null, 'dateStart', null);
            $writer->text($this->dateStart);
            $writer->endElement();
        }
        if ($this->dateEnd) {
            $writer->startElementNs(null, 'dateEnd', null);
            $writer->text($this->dateEnd);
            $writer->endElement();
        }
        if ($this->userID) {
            $writer->startElementNs(null, 'userID', null);
            $writer->text($this->userID);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
    }
}
